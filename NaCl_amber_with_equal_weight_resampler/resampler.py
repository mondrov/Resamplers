# -*- coding: utf-8 -*-
"""Resampler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YgW4vlPm81dPkqY_OQDb5GOsJMBIcptv
"""

# -*- coding: utf-8 -*-
"""Resampler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YgW4vlPm81dPkqY_OQDb5GOsJMBIcptv
"""

import logging
import math
import operator
import random

import numpy as np

import westpa
from westpa.core.we_driver import WEDriver
from westpa.core.segment import Segment
from westpa.core.states import InitialState

log=logging.getLogger(__name__)

class Equal_Weight_Driver(WEDriver): 
  def _equal_weight_resampler(self,bin,target_count,ideal_weight):
    #get walkers and their weights from current bin
    segments = np.array(sorted(bin, key=operator.attrgetter('weight')), dtype=np.object_)
    weights = np.array(list(map(operator.attrgetter('weight'), segments)))
    
    #initialize lists for the new walkers and their weights as well as a count of the new walkers
    new_walkers = []
    new_walker_count = 0 
    
    #sort the walkers in descending order based on their weight
    ind = np.argsort(-weights) ## this is done b/c argsort will sort in ascending order so if we put a neg sign then we'll have the bigger weights first
    weights[::-1].sort ## sort will sort in ascending order by default so reverse = True for descending order
    walkers_init = list(np.take(segments,ind))
    weights_descending = list(weights)
    
    #assign variable to last walker of the walker list as the starting point for while loop
    segment = walkers_init.pop()

    while True:
      #get weight corresponding to walker that is being processed
      walker_weight = weights_descending.pop()
      
      if walker_weight>=ideal_weight or len(walkers_init)==0:
        #min and max functions for round off errors
        r = max(1,int(np.floor(walker_weight/ideal_weight)))
        r = min(r,target_count-new_walker_count)
        
        #update number of walkers in the new walker list
        new_walker_count += r
        if r == 0:
            break
        #generate a walker from the walker being processed with target weight 'ideal_weight'
        for i in range(r):
            new_segment = Segment(
                    n_iter=segment.n_iter,
                    weight=ideal_weight,
                    parent_id=segment.parent_id,
                    wtg_parent_ids=set(segment.wtg_parent_ids),
                    pcoord=segment.pcoord.copy(),
                    status=Segment.SEG_STATUS_PREPARED,
            )
            new_segment.pcoord[0,:] = segment.pcoord[0,:]
            new_walkers.append(new_segment)
    
        #walker reinserted into intial walker list with leftover weight to maintain constant total weight
        if new_walker_count<target_count and walker_weight-r*ideal_weight>0.0:
          walkers_init.append(segment)
          weights_descending.append(walker_weight-r*ideal_weight)
           
        #assign next walker for processing
        if len(walkers_init)>0:
          segment=walkers_init.pop()
        
        else:
          break
      #if segment is underweight, process here
      else:
        next_walker = walkers_init.pop()
        next_walker_weight = weights_descending.pop()
        sum_walkers_weight = next_walker_weight + walker_weight
      
        #randomly select a number between 0 and 1  
        random_number=random.random()
       
        #if passes, set the conformation of the walker being processed equal to the next walker in the list
        if random_number < next_walker_weight / sum_walkers_weight:
          segment = next_walker
        
        #append the sum weight for reselection in the next iteration, thus conserving total weight
        weights_descending.append(sum_walkers_weight)  ## the original code actually replace this entry in weights_descending with the new summed weight but since you're using pop(), this seems fine
        
         
    #remove the old list of walkers from the bin and replace with the new list of walkers
    bin.clear()
    bin.update(new_walkers)

  
  def _run_we(self):
     self._recycle_walkers()
     
     self._check_pre()
     total_number_of_particles = 0
     for (ibin, bin) in enumerate(self.next_iter_binning):
       
       #if bin is empty move on to next iteration
       if len(bin) == 0:
         continue
       
       #Get the target walker count and ideal weight for the bin
       target_count = self.bin_target_counts[ibin]
       segments = np.array(sorted(bin, key=operator.attrgetter('weight')), dtype=np.object_)
       weights = np.array(list(map(operator.attrgetter('weight'), segments)))
       ideal_weight = weights.sum() / target_count
    
       #Check if the bin already has the target number of walkers with weight evenly distributed and continue on to next iteration if so
       
       if len(bin) == target_count:
         TF=[]
         for i in range(len(bin)):
           if weights[i] == ideal_weight:
             TF.append(True)
           else:
             TF.append(False)
         if all(TF) == True:
           continue 
       
       #run resampler on current bin
       self._equal_weight_resampler(bin,target_count,ideal_weight)
       total_number_of_particles += len(bin)
       #bin.clear()
     self._check_post()
     
     self.new_weights = self.new_weights or []
     log.debug('used intial states: {!r}'.format(self.used_initial_states))
     log.debug('available initial states: {!r}'.format(self.avail_initial_states))

